// Listing data models and validation schemas
import Joi from 'joi';

// Listing status
export const LISTING_STATUS = {
  DRAFT: 'draft',
  ACTIVE: 'active',
  INACTIVE: 'inactive',
  PENDING_REVIEW: 'pending_review',
  REJECTED: 'rejected',
  SUSPENDED: 'suspended'
};

// Service categories
export const SERVICE_CATEGORIES = {
  HOME_REPAIR: 'home_repair',
  CLEANING: 'cleaning',
  LANDSCAPING: 'landscaping',
  PAINTING: 'painting',
  PLUMBING: 'plumbing',
  ELECTRICAL: 'electrical',
  HVAC: 'hvac',
  HANDYMAN: 'handyman',
  MOVING: 'moving',
  OTHER: 'other'
};

// Pricing types
export const PRICING_TYPES = {
  FIXED: 'fixed',
  HOURLY: 'hourly',
  PER_SQUARE_FOOT: 'per_square_foot',
  CUSTOM: 'custom'
};

// Base listing schema
export const listingSchema = Joi.object({
  id: Joi.string().allow(null), // Will be auto-generated by Firestore
  providerId: Joi.string().required(),
  title: Joi.string().min(3).max(100).required(),
  category: Joi.string().valid(...Object.values(SERVICE_CATEGORIES)).required(),
  description: Joi.string().min(10).max(1000).required(),
  images: Joi.array().items(Joi.object({
    url: Joi.string().uri().required(),
    filename: Joi.string().required(),
    uploadedAt: Joi.date().default(() => new Date()),
    isPrimary: Joi.boolean().default(false)
  })).max(10).default([]),
  pricing: Joi.object({
    type: Joi.string().valid(...Object.values(PRICING_TYPES)).required(),
    amount: Joi.number().min(0).required(),
    currency: Joi.string().valid('USD', 'CAD', 'EUR').default('USD'),
    description: Joi.string().max(200).allow('')
  }).required(),
  availability: Joi.object({
    schedule: Joi.string().max(200).allow(''),
    timeSlots: Joi.array().items(Joi.object({
      day: Joi.string().valid('monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday').required(),
      startTime: Joi.string().pattern(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/).required(),
      endTime: Joi.string().pattern(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/).required(),
      available: Joi.boolean().default(true)
    })).default([]),
    responseTime: Joi.string().max(100).allow('')
  }).default({}),
  location: Joi.object({
    coverage: Joi.string().max(200).required(),
    serviceRadius: Joi.number().min(0).max(1000).default(50), // in miles/km
    specificAreas: Joi.array().items(Joi.string()).default([])
  }).required(),
  contactInfo: Joi.object({
    email: Joi.string().email().allow(''),
    phone: Joi.string().pattern(/^\+?[1-9]\d{1,14}$/).allow(''),
    preferredContact: Joi.string().valid('email', 'phone', 'both').default('both')
  }).default({}),
  status: Joi.string().valid(...Object.values(LISTING_STATUS)).default(LISTING_STATUS.DRAFT),
  featured: Joi.boolean().default(false),
  tags: Joi.array().items(Joi.string().max(30)).max(10).default([]),
  requirements: Joi.object({
    minimumOrder: Joi.number().min(0).allow(null),
    advanceBooking: Joi.number().min(0).default(24), // hours
    specialRequirements: Joi.string().max(500).allow('')
  }).default({}),
  statistics: Joi.object({
    views: Joi.number().min(0).default(0),
    inquiries: Joi.number().min(0).default(0),
    bookings: Joi.number().min(0).default(0),
    rating: Joi.number().min(0).max(5).default(0),
    totalReviews: Joi.number().min(0).default(0)
  }).default({}),
  createdAt: Joi.date().default(() => new Date()),
  updatedAt: Joi.date().default(() => new Date()),
  publishedAt: Joi.date().allow(null),
  expiresAt: Joi.date().allow(null)
});

// Validation functions
export const validateListing = (listingData) => {
  const validation = listingSchema.validate(listingData, { abortEarly: false });
  
  if (validation.error) {
    throw new Error(`Validation error: ${validation.error.details.map(d => d.message).join(', ')}`);
  }
  
  return validation.value;
};

// Helper function to create listing document
export const createListingDocument = (listingData) => {
  const validatedData = validateListing(listingData);
  
  // Set timestamps
  const now = new Date();
  validatedData.createdAt = now;
  validatedData.updatedAt = now;
  
  // Set default status if not provided
  if (!validatedData.status) {
    validatedData.status = LISTING_STATUS.DRAFT;
  }
  
  // Remove undefined values recursively to avoid Firestore errors
  const removeUndefinedDeep = (value) => {
    if (Array.isArray(value)) {
      return value.map(removeUndefinedDeep);
    }
    if (value && typeof value === 'object') {
      const result = {};
      Object.keys(value).forEach((key) => {
        const v = value[key];
        if (v !== undefined) {
          result[key] = removeUndefinedDeep(v);
        }
      });
      return result;
    }
    return value;
  };

  return removeUndefinedDeep(validatedData);
};

// Helper function to update listing document
export const updateListingDocument = (existingData, updateData) => {
  // Merge existing data with updates
  const mergedData = { ...existingData, ...updateData };

  // Normalize Firestore Timestamp values to JS Date before validation
  const toJsDate = (value) => {
    if (!value) return value;
    if (value instanceof Date) return value;
    if (typeof value.toDate === 'function') return value.toDate();
    const parsed = new Date(value);
    return isNaN(parsed.getTime()) ? value : parsed;
  };

  // Never allow createdAt to be overridden by updates
  mergedData.createdAt = toJsDate(existingData?.createdAt);
  mergedData.createdAt = toJsDate(mergedData.createdAt);
  mergedData.updatedAt = toJsDate(mergedData.updatedAt);
  mergedData.publishedAt = toJsDate(mergedData.publishedAt);
  mergedData.expiresAt = toJsDate(mergedData.expiresAt);

  if (Array.isArray(mergedData.images)) {
    mergedData.images = mergedData.images.map((img) => ({
      ...img,
      uploadedAt: toJsDate(img?.uploadedAt)
    }));
  }
  
  // Ensure required timestamps exist before validation
  if (!(mergedData.createdAt instanceof Date)) {
    mergedData.createdAt = new Date();
  }
  mergedData.updatedAt = new Date();
  
  // Validate the merged data
  const validatedData = validateListing(mergedData);
  
  // Update timestamp
  validatedData.updatedAt = new Date();
  
  // Remove undefined values recursively to avoid Firestore errors
  const removeUndefinedDeep = (value) => {
    if (Array.isArray(value)) {
      return value.map(removeUndefinedDeep);
    }
    if (value && typeof value === 'object') {
      const result = {};
      Object.keys(value).forEach((key) => {
        const v = value[key];
        if (v !== undefined) {
          result[key] = removeUndefinedDeep(v);
        }
      });
      return result;
    }
    return value;
  };

  return removeUndefinedDeep(validatedData);
};

// Query filters schema
export const listingFiltersSchema = Joi.object({
  status: Joi.string().valid(...Object.values(LISTING_STATUS)),
  category: Joi.string().valid(...Object.values(SERVICE_CATEGORIES)),
  providerId: Joi.string(),
  featured: Joi.boolean(),
  minPrice: Joi.number().min(0),
  maxPrice: Joi.number().min(0),
  location: Joi.string(),
  tags: Joi.array().items(Joi.string()),
  sortBy: Joi.string().valid('createdAt', 'updatedAt', 'title', 'pricing.amount', 'statistics.rating', 'statistics.views'),
  sortOrder: Joi.string().valid('asc', 'desc').default('desc'),
  limit: Joi.number().min(1).max(100).default(20),
  offset: Joi.number().min(0).default(0)
});

export const validateListingFilters = (filters) => {
  const validation = listingFiltersSchema.validate(filters, { abortEarly: false });
  
  if (validation.error) {
    throw new Error(`Filter validation error: ${validation.error.details.map(d => d.message).join(', ')}`);
  }
  
  return validation.value;
};
